from django.db import models
from django.templatetags.static import static
from django.utils import timezone
from datetime import datetime, timedelta
import secrets
import string

# Create your models here.


class User(models.Model):
    """
    This class represents a single user. Each user has their own associated data
    such as display name, picture, friends, etc.
    """
    # Name of the user
    name = models.CharField(max_length=128)
    # Introduction text about user
    intro_text = models.TextField(blank=True)
    # Portrait picture
    portrait_link = models.URLField(blank=True, null=True)
    # Is a verified user (gets a special badge)
    is_verified = models.BooleanField(default=False)

    # TODO: Friends/Connections. Need some many-to-many relationship

    def get_portrait_url(self):
        if self.portrait_link is not None:
            return self.portrait_link
        else:
            return static('img/default_user_profile.png')

    def __str__(self):
        return "User{%d, %s}" % (self.id, self.name)


class RealUser(User):
    """
    This class represents a "real user". RealUsers provide the functionality
    required to maintain login/session data, thus allowing "real users" to
    interact in ways that a default user cannot.

    The key different here is that default Users are typically going to be fake
    static users generated by Admins, while RealUsers are real humans who can
    log in and interact dynamically with the website
    """
    # The user name
    user_name = models.CharField(max_length=128, unique=True)
    # The session ID for this user
    session_id = models.CharField(max_length=128, blank=True, null=True)
    # session id expiration (default is epoch time)
    expiration_time = models.DateTimeField(default=datetime.utcfromtimestamp(0), null=True)
    # Whether this user's actions are being tracked
    track_enabled = models.BooleanField(default=False)

    # Attempt to authenticate, checking that session id has not expired, and
    # sessionIds match.
    def attempt_authentication(self, provided_session_id):
        if self.expiration_time is not None and timezone.now() >= self.expiration_time:
            return False
        return self.session_id is not None and self.session_id == provided_session_id

    def authenticate(self):
        # encrypt id with server-known Secret Key
        # session id must be <= 128 characters
        self.session_id = str(self.id) + "|" + ''.join(secrets.choice(string.ascii_letters) for _ in range(100))
        self.expiration_time = timezone.now() + timedelta(hours=6)
        self.save()
        return self.session_id, self.expiration_time

    def deauthenticate(self):
        self.expiration_time = None
        self.session_id = None
        self.save()


class Post(models.Model):
    """
    This class represents a single user Post, with all associated media, text
    author data as well as interaction data such as likes and shares
    """
    # Post create date/time
    create_date = models.DateTimeField('date created')
    # Post content
    text = models.TextField()
    # FK to author
    author = models.ForeignKey(User, on_delete=models.CASCADE)

    def __str__(self):
        return "Post{%d, %s, %s}" % (self.id, self.author, self.text[:20])


class CommentPost(Post):
    """
    This class represents a comment, with all associated media, text, author
    data as well as interaction data, such as likes and shares.
    Comments only differ from a Post in that they must link to another Post
    """

    parent_post = models.ForeignKey(Post, related_query_name="comment_parent_post", on_delete=models.CASCADE)

    def __str__(self):
        return "CommentPost{%d, %d, %s, %s}" % (self.id, self.parent_post.id, self.author, self.text[:20])


class ParentPost(Post):
    """
    This class represents a "parent post". That is, any post that was made that is
    not a comment.
    """

    def __str__(self):
        return "ParentPost{%d, %s, %s}" % (self.id, self.author, self.text[:20])


class PostInteractionTracker(models.Model):
    """
    This class is for storing information about the user interactions
    """
    # the name of the action
    action = models.CharField(max_length=32)
    # the content of the action
    content = models.TextField()
    # the post interacting with
    post = models.ForeignKey(Post, on_delete=models.CASCADE)
    # the user
    user = models.ForeignKey(RealUser, on_delete=models.CASCADE)
    # create time
    timestamp = models.DateTimeField(auto_now_add=True)
